---
phase: 01-core-mcp-server
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/index.ts
  - src/emacs-interface.ts
  - emacs/ask-user.el
autonomous: true

must_haves:
  truths:
    - "AskUserQuestion tool appears in tools/list response"
    - "Tool call with question spawns emacsclient process"
    - "User response from Emacs returns to Claude"
    - "Timeout after 5 minutes produces error message (not crash)"
    - "No command injection vulnerability (spawn uses argument arrays)"
  artifacts:
    - path: "src/index.ts"
      provides: "MCP server with AskUserQuestion tool registered"
      contains: "registerTool"
    - path: "src/emacs-interface.ts"
      provides: "Secure emacsclient spawning with timeout"
      exports: ["askViaEmacs"]
      min_lines: 40
    - path: "emacs/ask-user.el"
      provides: "Elisp function for minibuffer prompts"
      contains: "defun ask-user-question"
  key_links:
    - from: "src/index.ts"
      to: "src/emacs-interface.ts"
      via: "import askViaEmacs"
      pattern: "import.*askViaEmacs.*from.*emacs-interface"
    - from: "src/emacs-interface.ts"
      to: "emacsclient"
      via: "spawn with argument array"
      pattern: "spawn\\([\"']emacsclient[\"'].*\\["
    - from: "emacs/ask-user.el"
      to: "minibuffer"
      via: "read-from-minibuffer call"
      pattern: "read-from-minibuffer"
---

<objective>
Implement the AskUserQuestion tool that bridges Claude's questions to Emacs minibuffer via emacsclient. Complete the end-to-end flow: Claude calls tool -> emacsclient spawns -> user sees prompt -> response returns.

Purpose: Deliver the core value - Claude can pause and ask clarifying questions that appear in Emacs.

Output: Working MCP tool that prompts users via Emacs and returns their responses, with 5-minute timeout.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-mcp-server/01-RESEARCH.md
@.planning/phases/01-core-mcp-server/01-CONTEXT.md
@.planning/phases/01-core-mcp-server/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create emacsclient interface with secure spawning and timeout</name>
  <files>src/emacs-interface.ts</files>
  <action>
Create src/emacs-interface.ts with secure emacsclient spawning:

1. Create escapeElispString(str: string): string function:
   - Escape backslashes: \\ -> \\\\
   - Escape double quotes: " -> \\"
   - This prevents elisp code injection

2. Create withTimeout<T>(promise: Promise<T>, timeoutMs: number, timeoutError: string): Promise<T> function:
   - Uses Promise.race between the promise and a timeout
   - Timeout rejects with provided error message
   - Clean implementation (no AbortController needed for simplicity)

3. Create askViaEmacs(question: string, header?: string): Promise<string> function:
   - Format prompt according to CONTEXT.md decisions:
     - With header: `Header: Question > `
     - Without header: `Question > `
   - Build elisp expression: `(ask-user-question "escaped_prompt")`
   - CRITICAL: Use spawn() with argument ARRAY (not shell string):
     ```typescript
     spawn("emacsclient", ["--eval", elispExpr])
     ```
   - Collect stdout (elisp return value)
   - Collect stderr (for error messages)
   - Handle process close:
     - Exit code 0: resolve with stdout (trimmed, with elisp quotes removed)
     - Non-zero: reject with error including stderr
   - Handle process error event (e.g., emacsclient not found)
   - Wrap entire operation in withTimeout(promise, 5 * 60 * 1000, "Question timed out after 5 minutes")

4. Export askViaEmacs function

Note on elisp return values: emacsclient --eval prints the return value with surrounding quotes like "user input". Strip the outer quotes when parsing stdout.

Security requirement (EMACS-01): NEVER use shell: true or string concatenation for spawn arguments. Always use argument arrays.
  </action>
  <verify>
Run: `npm run build` - should compile without errors
Run: `grep -n "spawn.*emacsclient" src/emacs-interface.ts` - should show spawn with array syntax
Run: `grep -n "shell.*true" src/emacs-interface.ts` - should return nothing (no shell: true)
  </verify>
  <done>
emacs-interface.ts exports askViaEmacs function. Spawn uses argument arrays (secure). 5-minute timeout implemented. Elisp strings properly escaped.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register AskUserQuestion tool with Zod validation</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to register the AskUserQuestion tool:

1. Add imports:
   - z from "zod"
   - askViaEmacs from "./emacs-interface.js" (note .js extension for ES modules)

2. Register tool BEFORE server.connect() (order matters):
   ```typescript
   server.registerTool(
     "AskUserQuestion",
     {
       description: "Ask the user a question via Emacs minibuffer and wait for their response. Use this when you need clarification or user input.",
       inputSchema: {
         question: z.string().describe("The question to ask the user"),
         header: z.string().optional().describe("Optional header/context shown before the question"),
       },
     },
     async ({ question, header }) => {
       // Tool implementation
     }
   );
   ```

3. Implement tool handler:
   - Call askViaEmacs(question, header)
   - On success: return { content: [{ type: "text", text: response }] }
   - On timeout/error: return { content: [{ type: "text", text: error.message }] }
     - Do NOT throw - return errors as content so Claude sees them
   - Wrap in try/catch to handle all failure modes gracefully

4. Keep existing main() and server.connect() code after tool registration

Tool satisfies requirements:
- TOOL-01: question string parameter
- TOOL-02: returns user's text response
- TOOL-03: times out after 5 minutes with graceful error
- MCP-03: tools/list will include AskUserQuestion
- MCP-04: tools/call works
- MCP-05: Zod schema validation
  </action>
  <verify>
Run: `npm run build` - should compile without errors
Run: `grep -n "registerTool" src/index.ts` - should show AskUserQuestion registration
Run: `grep -n "z.string()" src/index.ts` - should show Zod schema usage
  </verify>
  <done>
AskUserQuestion tool registered with Zod schema. Tool handler calls askViaEmacs. Errors returned as content (not thrown). Tool registration happens before server.connect().
  </done>
</task>

<task type="auto">
  <name>Task 3: Create elisp function for minibuffer prompts</name>
  <files>emacs/ask-user.el</files>
  <action>
Create emacs/ask-user.el with the minibuffer prompt function:

1. Create function (ask-user-question prompt):
   - Takes single PROMPT argument (already formatted by Node.js)
   - Uses read-from-minibuffer to get user input
   - Returns the user's response string

Simple implementation for Phase 1:
```elisp
;;; ask-user.el --- MCP AskUserQuestion support for agent-shell -*- lexical-binding: t -*-

;;; Commentary:
;; Provides minibuffer prompting for the ask-user-mcp server.
;; Load this file in your Emacs config to enable AskUserQuestion tool support.

;;; Code:

(defun ask-user-question (prompt)
  "Prompt user with PROMPT in minibuffer and return their response.
PROMPT is the formatted question string from the MCP server."
  (read-from-minibuffer prompt))

(provide 'ask-user)

;;; ask-user.el ends here
```

Note: Phase 3 will add styling and the mr-x/ask-user-question variant. For Phase 1, basic read-from-minibuffer is sufficient to prove the flow works.

The prompt formatting (header prefix, "> " suffix) is done in emacs-interface.ts, so elisp just needs to display what it receives.
  </action>
  <verify>
Run: `cat emacs/ask-user.el` - should show defun ask-user-question
Run: `grep -n "read-from-minibuffer" emacs/ask-user.el` - should show the prompt call
  </verify>
  <done>
elisp function exists in emacs/ask-user.el. Uses read-from-minibuffer for prompts. File has proper Emacs Lisp headers and provide statement.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `grep -rn "spawn.*\[" src/` shows array argument syntax (security check)
3. `grep -rn "shell.*true" src/` returns nothing (no shell: true)
4. Server starts: `timeout 2 node build/index.js 2>&1 || true`
5. Manual test (if Emacs server running):
   - Run server: `node build/index.js`
   - Send JSON-RPC tools/list request
   - Verify AskUserQuestion appears in response
</verification>

<success_criteria>
- AskUserQuestion tool registered with Zod schema validation
- emacsclient spawned with argument arrays (no command injection)
- 5-minute timeout implemented with graceful error message
- elisp function created for minibuffer prompts
- Tool errors returned as content (not thrown)
- Full end-to-end flow works: Claude -> MCP -> emacsclient -> Emacs -> response
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-mcp-server/01-02-SUMMARY.md`
</output>
