---
phase: 04-core-popup-infrastructure
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/emacs-interface.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "MCP server calls mr-x/ask-user-popup (v2) instead of mr-x/ask-user-question (v1)"
    - "Users see popup buffer when Claude asks a question via MCP tool"
    - "Graceful fallback to v1 function if popup not defined"
  artifacts:
    - path: "src/emacs-interface.ts"
      provides: "emacsclient integration calling v2 popup"
      contains: "mr-x/ask-user-popup"
  key_links:
    - from: "src/emacs-interface.ts"
      to: "emacs/ask-user-popup.el"
      via: "emacsclient --eval calling mr-x/ask-user-popup"
      pattern: "mr-x/ask-user-popup"
---

<objective>
Wire MCP server to call the v2 popup function instead of v1 minibuffer function.

Purpose: Complete the end-to-end integration so users see the popup buffer when Claude asks questions
Output: Updated emacs-interface.ts that calls mr-x/ask-user-popup with graceful fallback
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-popup-infrastructure/04-VERIFICATION.md

# Prior work that established the popup function
@.planning/phases/04-core-popup-infrastructure/04-01-SUMMARY.md
@.planning/phases/04-core-popup-infrastructure/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update askViaEmacs to call v2 popup function</name>
  <files>src/emacs-interface.ts</files>
  <action>
Update the elisp expression in askViaEmacs() to call mr-x/ask-user-popup instead of mr-x/ask-user-question.

Current code (lines 52-62):
```typescript
const elispExpr = `(condition-case err
    (mr-x/ask-user-question "${escapedQuestion}" ${headerArg})
  (void-function
    (progn
      (message "ask-user-mcp: mr-x/ask-user-question not defined, using read-string")
      (read-string "Claude asks: ${escapedQuestion} "))))`;
```

Changes required:

1. Rename `headerArg` to `descriptionArg` for clarity (line 49-51):
   ```typescript
   const descriptionArg = options.header 
     ? `"${escapeElispString(options.header)}"` 
     : "nil";
   ```

2. Update the elisp expression to call v2 popup with proper fallback chain:
   ```typescript
   // Build elisp with graceful fallback chain:
   // 1. Try v2 popup (mr-x/ask-user-popup)
   // 2. Fall back to v1 minibuffer (mr-x/ask-user-question)
   // 3. Ultimate fallback to read-string
   const elispExpr = `(condition-case err
       (mr-x/ask-user-popup "${escapedQuestion}" ${descriptionArg})
     (void-function
       (condition-case err2
           (progn
             (message "ask-user-mcp: popup not available, using v1 minibuffer")
             (mr-x/ask-user-question "${escapedQuestion}" ${descriptionArg}))
         (void-function
           (progn
             (message "ask-user-mcp: no ask-user functions defined, using read-string")
             (read-string "Claude asks: ${escapedQuestion} "))))))`;
   ```

3. Update the comment before the elisp expression to reflect the new fallback chain.

The v2 popup function signature matches what we need:
- (mr-x/ask-user-popup QUESTION &optional DESCRIPTION)
- Same as v1: (mr-x/ask-user-question QUESTION &optional HEADER)

The options.header parameter maps semantically to "description" in v2 - both serve the same purpose of providing additional context below the main question.
  </action>
  <verify>
Run TypeScript compilation:
```bash
cd "/Users/marcosandrade/roaming/projects/MCP servers/ask-user-mcp" && npm run build
```
Verify no compilation errors.
  </verify>
  <done>
- src/emacs-interface.ts calls mr-x/ask-user-popup as primary function
- Fallback chain: popup -> v1 minibuffer -> read-string
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify end-to-end integration</name>
  <files>src/emacs-interface.ts</files>
  <action>
Verify the wiring is complete by checking the built JavaScript output.

1. Confirm the built file contains mr-x/ask-user-popup:
   ```bash
   grep -n "mr-x/ask-user-popup" dist/emacs-interface.js
   ```
   Should find the popup call in the elisp expression.

2. Confirm the fallback chain is present:
   ```bash
   grep -n "mr-x/ask-user-question" dist/emacs-interface.js
   ```
   Should find this as the fallback (not primary).

3. Read the compiled elisp expression to verify structure:
   ```bash
   grep -A 15 "condition-case" dist/emacs-interface.js | head -20
   ```
   Should show nested condition-case for graceful degradation.

Do NOT run actual emacsclient tests in this task - the server integration is verified by code inspection and build success. Interactive testing requires Emacs environment which is outside scope.
  </action>
  <verify>
```bash
cd "/Users/marcosandrade/roaming/projects/MCP servers/ask-user-mcp" && \
grep "mr-x/ask-user-popup" dist/emacs-interface.js && \
echo "Popup call found in build"
```
  </verify>
  <done>
- Built JavaScript contains mr-x/ask-user-popup call
- Fallback chain preserved in built output
- End-to-end wiring complete (code-verified)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation succeeds without errors
2. dist/emacs-interface.js contains mr-x/ask-user-popup
3. Fallback chain preserved: popup -> v1 -> read-string
4. No regression in existing functionality
</verification>

<success_criteria>
1. MCP server calls mr-x/ask-user-popup as the primary function
2. Graceful fallback chain ensures backwards compatibility
3. Build succeeds and tests pass
4. Phase 04 goal achieved: "Users see questions in a dedicated popup buffer"
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-popup-infrastructure/04-03-SUMMARY.md`
</output>
