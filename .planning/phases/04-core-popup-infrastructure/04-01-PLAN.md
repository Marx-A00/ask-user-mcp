---
phase: 04-core-popup-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - emacs/ask-user-popup.el
autonomous: true

must_haves:
  truths:
    - "Popup buffer appears at bottom of frame when function called"
    - "Buffer uses ask-user-popup-mode derived from special-mode"
    - "Calling function blocks until user exits (recursive-edit)"
    - "Buffer is killed after user completes interaction"
  artifacts:
    - path: "emacs/ask-user-popup.el"
      provides: "Core popup infrastructure"
      min_lines: 40
      exports:
        - "ask-user-popup-mode"
        - "mr-x/ask-user-popup"
  key_links:
    - from: "emacs/ask-user-popup.el"
      to: "display-buffer-at-bottom"
      via: "buffer positioning"
      pattern: "display-buffer-at-bottom"
    - from: "emacs/ask-user-popup.el"
      to: "recursive-edit"
      via: "blocking behavior"
      pattern: "recursive-edit"
---

<objective>
Create the core popup buffer infrastructure for Claude's question UI.

Purpose: Establish the foundation that Phase 5 will build interaction modes on top of. This plan delivers a working popup buffer with proper lifecycle management.

Output: New `emacs/ask-user-popup.el` file with major mode and popup display function.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-popup-infrastructure/04-CONTEXT.md

# Existing elisp to understand current patterns
@emacs/ask-user.el
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create major mode and popup display function</name>
  <files>emacs/ask-user-popup.el</files>
  <action>
Create new file `emacs/ask-user-popup.el` with:

1. **Major mode definition:**
   - `define-derived-mode ask-user-popup-mode special-mode "AskUser"`
   - Suppress mode line: `(setq-local mode-line-format nil)`
   - Buffer-local variable for result: `(defvar-local ask-user-popup--result nil)`
   - Buffer-local variable for cancelled state: `(defvar-local ask-user-popup--cancelled nil)`

2. **Popup display function `mr-x/ask-user-popup`:**
   - Parameters: `(question &optional description)`
   - Create buffer named `*ask-user*`
   - Switch to `ask-user-popup-mode`
   - Display buffer at bottom using:
     ```elisp
     (display-buffer buf
       '((display-buffer-at-bottom)
         (window-height . 0.4)
         (preserve-size . (nil . t))))
     ```
   - Select the popup window after display
   - Store question and description for later rendering (Task 2 will add visual layout)

3. **Blocking with recursive-edit:**
   - After display, call `(recursive-edit)`
   - This blocks until `exit-recursive-edit` is called
   - After recursive-edit returns, retrieve `ask-user-popup--result`
   - Return the result string (or signal error if cancelled)

4. **Cleanup with unwind-protect:**
   - Wrap the display/recursive-edit in `unwind-protect`
   - Cleanup form: kill buffer, delete window
   - Use `quit-window` with KILL parameter for atomic cleanup
   - Ensure cleanup runs even on C-g

5. **Keymap setup:**
   - Inherit from `special-mode-map`
   - Bind `q` to quit/cancel (calls cancel function)
   - Leave space for Phase 5 to add C-n/C-p bindings

Use lexical-binding. Add proper file header with Commentary section explaining this is for v2 popup UI.

Do NOT yet implement visual layout (header styling, description display) - that's Task 2.
  </action>
  <verify>
Test in Emacs scratch buffer:
```elisp
(load-file "emacs/ask-user-popup.el")
(mr-x/ask-user-popup "Test question?" "Optional description")
```
Verify:
- Popup appears at bottom of frame (~40% height)
- Buffer is in ask-user-popup-mode
- `q` closes popup and returns nil/error
- After closing, buffer is killed (check with `C-x C-b`)
  </verify>
  <done>
- Popup buffer appears at frame bottom when `mr-x/ask-user-popup` called
- Buffer uses `ask-user-popup-mode` (derived from special-mode)
- Function blocks until user presses `q` or triggers exit
- Buffer is killed after interaction completes
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement visual layout with header line</name>
  <files>emacs/ask-user-popup.el</files>
  <action>
Extend `emacs/ask-user-popup.el` to add visual layout:

1. **Header line for instructions:**
   - Set `header-line-format` in popup mode
   - Display contextual instruction (will vary in Phase 5: "Pick one" vs "Type response")
   - For now, use generic: `" Claude is asking..."`
   - Style with appropriate face (use `header-line` face)

2. **Question display (prominent at top):**
   - Insert question text at buffer start
   - Apply larger/bold styling using text properties:
     ```elisp
     (insert (propertize question 'face '(:weight bold :height 1.2)))
     ```
   - Add newline after question

3. **Description display (muted, below header):**
   - If description provided, insert below question
   - Apply muted styling: `'face 'shadow` or custom gray face
   - Add newline separator

4. **Content area separator:**
   - Add visual separator (empty line or thin rule) between header section and content area
   - Content area is where Phase 5 will render options or text input
   - For now, just insert placeholder text: "[Response area - Phase 5]"

5. **Buffer read-only:**
   - Set buffer as read-only after inserting content
   - Use `(setq buffer-read-only t)`

Visual layout per CONTEXT.md decisions:
- Header text larger and clearly distinguished
- Description in muted/gray color
- Compact vertical spacing
- Left-aligned throughout (no centering)
  </action>
  <verify>
Test in Emacs:
```elisp
(load-file "emacs/ask-user-popup.el")
(mr-x/ask-user-popup "What programming language should I use?" "Consider the project requirements and your team's expertise.")
```
Verify:
- Header line shows instruction at top of window
- Question displays in bold/larger text
- Description displays in muted/gray below question
- Clear visual separation between header section and content area
- Buffer content is read-only (typing does nothing)
  </verify>
  <done>
- Header line displays contextual instruction
- Question text is prominent (bold, larger)
- Description (when provided) displays in muted gray
- Content area is visually separated from header
- Buffer is read-only
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement C-g cancel behavior</name>
  <files>emacs/ask-user-popup.el</files>
  <action>
Add cancel handling to `emacs/ask-user-popup.el`:

1. **Cancel function:**
   ```elisp
   (defun ask-user-popup-cancel ()
     "Cancel the popup and return error to caller."
     (interactive)
     (setq ask-user-popup--cancelled t)
     (setq ask-user-popup--result nil)
     (message "Cancelled")
     (exit-recursive-edit))
   ```

2. **Bind C-g in keymap:**
   - In `ask-user-popup-mode-map`, bind `C-g` to `ask-user-popup-cancel`
   - Also bind `q` to same function for consistency with special-mode convention

3. **Handle cancelled state in main function:**
   - After `recursive-edit` returns, check `ask-user-popup--cancelled`
   - If cancelled, signal error: `(error "User cancelled the question")`
   - This error propagates to emacsclient, which returns non-zero exit code
   - Node.js will receive this as rejection

4. **Brief "Cancelled" message:**
   - Per CONTEXT.md: show brief message before closing
   - Use `(message "Cancelled")` in cancel function
   - No confirmation required - immediate cancel

5. **Test exit paths:**
   - Normal completion: sets result, calls `exit-recursive-edit`, returns result
   - C-g/q cancel: sets cancelled flag, calls `exit-recursive-edit`, signals error
   - Timeout (handled by emacsclient kill): cleanup runs via unwind-protect
  </action>
  <verify>
Test cancel behavior:
```elisp
(load-file "emacs/ask-user-popup.el")
;; Test 1: Press C-g
(condition-case err
    (mr-x/ask-user-popup "Test question?")
  (error (message "Got error: %s" err)))
;; Should show "Cancelled" message and return error

;; Test 2: Press q
(condition-case err
    (mr-x/ask-user-popup "Another question?")
  (error (message "Got error: %s" err)))
;; Same behavior
```
Verify:
- C-g shows "Cancelled" message and closes popup
- `q` does the same
- Error is signaled (caught by condition-case)
- Buffer is killed after cancel
  </verify>
  <done>
- C-g cancels popup and returns error to Claude
- `q` also cancels (special-mode convention)
- "Cancelled" message displays briefly
- Buffer cleanup occurs after cancel
- Error propagates to emacsclient caller
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Popup positioning:** Run `(mr-x/ask-user-popup "Test?")` and verify buffer appears at bottom, ~40% of frame height

2. **Mode verification:** In popup buffer, run `M-x describe-mode` and confirm `ask-user-popup-mode` is active

3. **Blocking behavior:** Confirm function doesn't return until popup is dismissed

4. **Cancel test:** Press C-g and verify error is signaled, buffer is killed

5. **Cleanup test:** After popup closes, run `(get-buffer "*ask-user*")` and verify it returns nil

6. **Visual check:** Question is bold, description is gray, header line shows instruction
</verification>

<success_criteria>
1. `emacs/ask-user-popup.el` exists with ~60-80 lines of working elisp
2. `mr-x/ask-user-popup` function creates popup at bottom of frame
3. Buffer uses `ask-user-popup-mode` derived from `special-mode`
4. Function blocks until user dismisses popup (recursive-edit pattern)
5. C-g cancels and signals error
6. Buffer is killed after interaction (no orphaned buffers)
7. Visual layout: bold question, muted description, header line with instruction
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-popup-infrastructure/04-01-SUMMARY.md`
</output>
