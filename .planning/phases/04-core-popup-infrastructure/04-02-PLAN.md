---
phase: 04-core-popup-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - emacs/ask-user-popup.el
autonomous: false

must_haves:
  truths:
    - "Popup works end-to-end via emacsclient"
    - "Question displays correctly with styled layout"
    - "Cancel returns error through emacsclient"
    - "No orphaned buffers after any exit path"
  artifacts:
    - path: "emacs/ask-user-popup.el"
      provides: "Complete popup infrastructure"
      min_lines: 60
  key_links:
    - from: "src/emacs-interface.ts"
      to: "emacs/ask-user-popup.el"
      via: "emacsclient --eval"
      pattern: "mr-x/ask-user-popup"
---

<objective>
Verify popup infrastructure works end-to-end with emacsclient integration.

Purpose: Ensure the popup buffer works correctly when called via emacsclient (how the MCP server will call it). This validates blocking behavior, return values, and error propagation before Phase 5 adds interaction modes.

Output: Verified working popup that can be called from command line.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-core-popup-infrastructure/04-CONTEXT.md
@.planning/phases/04-core-popup-infrastructure/04-01-SUMMARY.md

# Popup implementation
@emacs/ask-user-popup.el

# Existing integration for reference
@src/emacs-interface.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add load integration to ask-user.el</name>
  <files>emacs/ask-user.el</files>
  <action>
Update `emacs/ask-user.el` to load the popup module:

1. **Add require/load for popup module:**
   At the end of ask-user.el (before `provide`), add:
   ```elisp
   ;; Load popup UI module (v2)
   (require 'ask-user-popup nil t)  ; noerror if not found
   ```
   
   This ensures users who load ask-user.el also get the popup functionality.

2. **Add autoload cookie (optional but nice):**
   ```elisp
   ;;;###autoload
   (defun mr-x/ask-user-popup ...)
   ```
   If the function is defined in ask-user-popup.el, the autoload ensures it's available.

The popup module should be in the same directory as ask-user.el for the require to work.
Add a comment explaining that ask-user-popup.el provides v2 popup UI.
  </action>
  <verify>
In Emacs:
```elisp
(load-file "emacs/ask-user.el")
(fboundp 'mr-x/ask-user-popup)  ; Should return t
```
  </verify>
  <done>
- ask-user.el loads ask-user-popup.el when available
- Both v1 (minibuffer) and v2 (popup) functions accessible
  </done>
</task>

<task type="auto">
  <name>Task 2: Test emacsclient integration</name>
  <files>emacs/ask-user-popup.el</files>
  <action>
Test the popup via emacsclient to verify it works as the MCP server will call it:

1. **Create test script** `test-popup.sh`:
   ```bash
   #!/bin/bash
   # Test popup via emacsclient
   
   # First, ensure Emacs has loaded the popup module
   emacsclient --eval '(load-file "emacs/ask-user-popup.el")' 2>/dev/null
   
   # Test 1: Basic popup (user should press q to cancel)
   echo "Test 1: Basic popup - press q or C-g to cancel"
   result=$(emacsclient --eval '(mr-x/ask-user-popup "What is your favorite color?" "Choose wisely")')
   echo "Result: $result"
   echo "Exit code: $?"
   
   # Test 2: Verify return value format
   echo ""
   echo "Expected: Exit code 1 (error from cancel)"
   ```

2. **Run the test manually:**
   Execute `./test-popup.sh` from terminal with Emacs server running.

3. **Verify emacsclient behavior:**
   - Popup appears in Emacs when command runs
   - Terminal blocks until popup is dismissed
   - C-g returns non-zero exit code
   - Return value is properly quoted string

4. **Fix any issues:**
   If return value escaping is wrong, adjust how result is returned.
   The current implementation should work because we're returning a string
   and emacsclient auto-quotes it.

5. **Document in code:**
   Add comment in ask-user-popup.el explaining the emacsclient integration:
   ```elisp
   ;; This function is designed to be called via emacsclient:
   ;;   emacsclient --eval '(mr-x/ask-user-popup "question" "description")'
   ;; It blocks until user responds, then returns the response string.
   ;; Cancel (C-g/q) signals an error, causing non-zero exit code.
   ```
  </action>
  <verify>
From terminal (with Emacs server running):
```bash
# Load the module
emacsclient --eval '(load-file "emacs/ask-user-popup.el")'

# Test popup - press q to cancel
emacsclient --eval '(mr-x/ask-user-popup "Test?" "Desc")'
echo "Exit code: $?"
# Should show error and exit code 1
```
  </verify>
  <done>
- Popup appears when called via emacsclient
- emacsclient blocks until popup dismissed
- Cancel returns non-zero exit code
- Return value format is correct for Node.js parsing
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete popup buffer infrastructure:
- Popup appears at bottom of Emacs frame (~40% height)
- Question displays prominently with bold styling
- Description displays in muted gray below question
- Header line shows instruction
- C-g or q cancels and returns error
- Buffer is killed after interaction
  </what-built>
  <how-to-verify>
1. **In Emacs, evaluate:**
   ```elisp
   (load-file "emacs/ask-user-popup.el")
   (mr-x/ask-user-popup "What language should I use for this project?" "Consider performance requirements and team expertise.")
   ```

2. **Verify visuals:**
   - Popup appears at bottom (~40% of frame)
   - Question is bold and prominent
   - Description is gray/muted
   - Header line shows instruction text
   - No mode line in popup

3. **Test cancel:**
   - Press `C-g` - should show "Cancelled" and close
   - Try again and press `q` - same behavior
   - Verify no `*ask-user*` buffer remains

4. **Test from terminal (with Emacs server running):**
   ```bash
   emacsclient --eval '(mr-x/ask-user-popup "Terminal test?" "From shell")'
   # Press C-g in Emacs
   echo "Exit code: $?"  # Should be 1 (error)
   ```
  </how-to-verify>
  <resume-signal>Type "approved" if popup works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Phase 4 requirements verification:

- [x] POPUP-01: Popup buffer appears at bottom of frame (~40% height)
- [x] POPUP-02: Buffer uses dedicated major mode (special-mode derived)
- [x] POPUP-03: Buffer blocks until user responds (recursive-edit pattern)
- [x] POPUP-04: Buffer cleanup on exit (no orphaned buffers)
- [x] POPUP-05: C-g cancels and returns error to Claude
- [x] VIS-01: Question/header displayed prominently at top
- [x] VIS-02: Description (if provided) displayed below header
- [x] VIS-03: Options or text area clearly separated from header

Note: VIS-03 shows placeholder for now - actual options/text area comes in Phase 5.
</verification>

<success_criteria>
1. Popup appears at bottom of frame when `mr-x/ask-user-popup` called
2. Visual layout matches CONTEXT.md decisions (bold question, muted description, header line)
3. C-g cancels immediately with "Cancelled" message
4. Buffer is killed after any exit (no orphans)
5. Works via emacsclient with correct blocking and return value behavior
6. User has verified the visual appearance and behavior
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-popup-infrastructure/04-02-SUMMARY.md`
</output>
