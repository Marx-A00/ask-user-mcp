---
phase: 02-error-handling-reliability
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/errors.ts
  - src/emacs-interface.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Server detects Emacs server not running and returns actionable error message"
    - "Server handles malformed input without crashing"
    - "Timeout errors explain what happened and suggest increasing timeout_ms"
    - "Tool accepts optional timeout_ms parameter (30s-30min range)"
    - "Different error types produce different helpful messages"
  artifacts:
    - path: "src/errors.ts"
      provides: "Error classification function"
      exports: ["classifyEmacsError"]
    - path: "src/emacs-interface.ts"
      provides: "Configurable timeout, error classification"
      contains: "timeout_ms"
    - path: "src/index.ts"
      provides: "Updated tool schema with timeout_ms, isError flag"
      contains: "timeout_ms.*optional"
  key_links:
    - from: "src/emacs-interface.ts"
      to: "src/errors.ts"
      via: "import classifyEmacsError"
      pattern: "import.*classifyEmacsError"
    - from: "src/index.ts"
      to: "src/emacs-interface.ts"
      via: "passes timeout_ms to askViaEmacs"
      pattern: "askViaEmacs.*timeout"
---

<objective>
Implement comprehensive error handling with helpful messages and configurable timeouts.

Purpose: Make the server production-ready by detecting specific failure modes (Emacs not running, permission issues, timeouts) and returning actionable error messages that help Claude (and users) fix problems.

Output: Error classification module, updated emacs-interface with configurable timeout, and improved tool handler with isError flag.
</objective>

<execution_context>
@/Users/marcosandrade/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marcosandrade/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-handling-reliability/02-CONTEXT.md
@.planning/phases/02-error-handling-reliability/02-RESEARCH.md
@.planning/phases/02-error-handling-reliability/02-01-PLAN.md
@src/index.ts
@src/emacs-interface.ts
@src/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error classification module</name>
  <files>src/errors.ts</files>
  <action>
Create src/errors.ts with error classification function that parses emacsclient stderr and exit codes to produce helpful, conversational error messages.

The function classifyEmacsError(stderr: string, code: number): string should:

1. Check for "server not running" patterns (case-insensitive):
   - "can't find socket" -> "Emacs server isn't running. Start it with M-x server-start or run: emacsclient -e '(server-start)'"
   - "server-start" in message
   - "no socket"

2. Check for permission issues:
   - "permission denied" -> "Cannot connect to Emacs server socket. Check permissions on ~/.emacs.d/server/ directory."

3. Check for authentication failures:
   - "authentication failed" -> "Emacs server authentication failed. Check your server-auth-dir configuration."

4. Check for command not found:
   - exit code 127 OR "command not found" OR "not found" -> "emacsclient command not found. Install Emacs or ensure emacsclient is in your PATH."

5. Check for user cancellation (C-g):
   - "quit" in stderr OR (code === 1 AND empty stderr) -> "User cancelled the question."

6. Fallback with context:
   - If stderr has content: "emacsclient failed (exit code X): <stderr>"
   - Otherwise: "emacsclient failed with exit code X. Check that Emacs is running and accessible."

Export the function.
  </action>
  <verify>
npm run build compiles without errors.
File src/errors.ts exists.
Function classifyEmacsError is exported.
  </verify>
  <done>Error classification module exists with helpful message generation</done>
</task>

<task type="auto">
  <name>Task 2: Update emacs-interface with configurable timeout and error handling</name>
  <files>src/emacs-interface.ts</files>
  <action>
Modify src/emacs-interface.ts to:

1. Import error classifier: import { classifyEmacsError } from './errors.js';

2. Add options interface:
   export interface AskOptions {
     header?: string;
     timeout_ms?: number;
   }

3. Update function signature to accept options object:
   export async function askViaEmacs(question: string, options: AskOptions = {}): Promise<string>

4. At start of function, extract and validate timeout:
   - const timeout = options.timeout_ms ?? 5 * 60 * 1000  (default 5 minutes)
   - if timeout < 30_000, throw Error('Timeout must be at least 30 seconds (30000 ms)')
   - if timeout > 30 * 60_000, throw Error('Timeout cannot exceed 30 minutes (1800000 ms)')

5. Get header from options.header instead of second parameter.

6. Implement manual timeout tracking (workaround for Node.js limitation):
   - let timedOut = false;
   - const timeoutTimer = setTimeout(() => { timedOut = true; proc.kill('SIGTERM'); }, timeout);

7. In the promise resolution:
   - Clear timeoutTimer on process close event
   - If timedOut is true, throw with message: "Question timed out after X seconds waiting for response. If you need more time, increase the timeout_ms parameter (max 30 minutes)."
   - If exit code non-zero, use classifyEmacsError(stderr, code) for the error message

8. Remove the old withTimeout wrapper function (no longer needed).

9. Add logging:
   - logger.debug at start with question snippet (first 50 chars)
   - logger.error on failure with code and stderr
   - logger.debug on success with response length
  </action>
  <verify>
npm run build compiles without errors.
grep shows timeout_ms usage in src/emacs-interface.ts.
grep shows classifyEmacsError import.
grep shows timedOut variable for manual timeout tracking.
  </verify>
  <done>emacs-interface supports configurable timeout with bounds checking and produces classified error messages</done>
</task>

<task type="auto">
  <name>Task 3: Update tool schema and handler with timeout_ms and isError</name>
  <files>src/index.ts</files>
  <action>
Modify src/index.ts tool registration:

1. Update inputSchema to add timeout_ms with Zod:
   - question: z.string().min(1, "Question cannot be empty").describe("The question to ask the user")
   - header: z.string().optional().describe("Optional header/context shown before the question")
   - timeout_ms: z.number().min(30000, "Timeout must be at least 30 seconds").max(30 * 60000, "Timeout cannot exceed 30 minutes").optional().describe("Timeout in milliseconds (default: 300000 = 5 minutes)")

2. Update tool handler to pass options object to askViaEmacs:
   - const response = await askViaEmacs(args.question, { header: args.header, timeout_ms: args.timeout_ms })

3. Update error response to include isError: true per MCP spec:
   - In catch block, return { isError: true, content: [{ type: "text", text: errorMessage }] }

4. Log failed tool calls at warn level before returning error response.

Key changes:
- Add .min(1) to question string to catch empty questions
- Pass options object instead of separate arguments
- isError flag signals tool error vs normal content
  </action>
  <verify>
npm run build compiles without errors.
grep shows timeout_ms in src/index.ts tool schema.
grep shows isError in error response.
grep shows min(1) for empty question validation.
  </verify>
  <done>Tool schema includes timeout_ms parameter, handler returns isError on failures, input validated with helpful messages</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build verification: npm run build should compile without errors.

2. Error classification can be tested manually by importing and calling classifyEmacsError with various inputs.

3. Tool schema verification: Send tools/list JSON-RPC request and verify timeout_ms appears in tool definition.
</verification>

<success_criteria>
- Error classification module detects Emacs server unavailable, permission issues, timeouts
- emacs-interface accepts configurable timeout_ms (30s-30min bounds)
- Tool schema includes optional timeout_ms parameter
- Error responses include isError: true flag
- Input validation has helpful custom error messages
- Build compiles cleanly
- Requirements addressed: TOOL-04, EMACS-02, ERR-01, ERR-02
</success_criteria>

<output>
After completion, create .planning/phases/02-error-handling-reliability/02-02-SUMMARY.md
</output>
